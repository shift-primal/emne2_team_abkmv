import { builders as M, utils as si } from "prettier/doc";
import fi from "prettier/parser-babel";
import yi from "prettier/parser-espree";
import _i from "prettier/parser-flow";
import $i from "prettier/parser-meriyah";
import vi from "prettier/parser-typescript";
import { printers as Di } from "prettier/plugins/estree.mjs";
import { resolveConfigFile as Ti } from "prettier";
const { group: Mi, indent: Ai, softline: Be, hardline: Si, lineSuffixBoundary: ki } = M, { mapDoc: Li } = si;
function Gi(e, t) {
  const { node: n } = e;
  let r = t();
  return n?.comments?.length && (r = Mi([Ai([Be, r]), Be])), ["${", r, ki, "}"];
}
function k(e, t) {
  return e.map(
    (n) => Gi(n, t),
    "expressions"
  );
}
function S(e, t, n, r = !1) {
  return Li(e, (o) => {
    if (typeof o != "string")
      return o;
    const i = [], l = o.split(t);
    for (let u = 0; u < l.length; u++) {
      let E = l[u];
      if (u % 2 === 0) {
        if (!E)
          continue;
        if (E = E.replaceAll(/([\\`]|\${)/g, "\\$1"), r)
          for (const d of E.split(/(\n)/))
            d === `
` ? i.push(Si) : i.push(d);
        else
          i.push(E);
      } else {
        const d = Number(E);
        i.push(n[d]);
      }
    }
    return i;
  });
}
function Ni(e, t, n) {
  if (t === n) {
    e.unshift(t);
    return;
  }
  let r = 0, s = e.length;
  for (; r < s; ) {
    const o = r + s >>> 1;
    if (e[o] === n) {
      e.push(t);
      return;
    }
    e[o] < t ? r = o + 1 : s = o;
  }
  e.splice(r, 0, t);
}
const he = (() => {
  const e = [...Array(26).keys()].map((t) => String.fromCharCode(t + 97)).concat([...Array(10).keys()].map((t) => `${t}`));
  return () => {
    let n = "";
    for (let r = 0; r < 16; ++r)
      n += e[Number.parseInt((Math.random() * e.length).toFixed(0), 10) % e.length];
    return n;
  };
})();
function L(e = "p", t = "") {
  const n = he(), r = he(), s = qe(e), o = qe(t), i = (u) => `${e}${n}${u}${r}${t}`, l = new RegExp(
    `${s}${n}(\\d+)${r}${o}`,
    "ig"
  );
  return {
    createPlaceholder: i,
    placeholderRegex: l
  };
}
function qe(e) {
  return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function D(e) {
  return `${e}Identifiers`;
}
function A(e) {
  return `${e}Comments`;
}
function T(e) {
  return `${e}Tags`;
}
function Oi(e) {
  return `${e}Plugin`;
}
function O(e) {
  return `${e}Parser`;
}
const _ = "9ff2b366e8ca4c97b9aed1a29b5b94ed", { line: je, group: I, indent: Ue, softline: Re } = M, xi = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(
    "@prettier-placeholder"
  ), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: i.embeddedCssParser ?? "scss"
  }), a = S(
    $,
    E,
    b,
    // https://github.com/prettier/prettier/blob/3bfabd012873e5022f341aca75566966d91870f1/src/language-js/embed/css.js#L52
    !0
  );
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return I([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [I(a)] : Ue([I(a)]),
      p,
      "`"
    ]);
  const h = c.length ? je : Re, v = p.length ? je : Re;
  return I([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, I(a)] : Ue([h, I(a)]),
    v,
    "`"
  ]);
}, re = "embeddedCss", Ii = ["css"], Pi = ["css", "less", "scss"], Bi = D(re), Ce = A(re), we = T(re), qi = O(re), ji = {
  [Bi]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ii] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded CSS language.",
    deprecated: `Please use \`${Ce}\` or \`${we}\`.`
  },
  [Ce]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded CSS language."
  },
  [we]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded CSS language."
  },
  [qi]: {
    category: "Embed",
    type: "choice",
    default: "scss",
    description: "The parser used to parse the embedded CSS language.",
    choices: Pi.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Ui = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: xi,
  language: re,
  options: ji
}, Symbol.toStringTag, { value: "Module" })), { line: Fe, group: P, indent: We, softline: ze } = M, Ri = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: i.embeddedEsParser ?? "babel"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return P([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [P(a)] : We([P(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Fe : ze, v = p.length ? Fe : ze;
  return P([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, P(a)] : We([h, P(a)]),
    v,
    "`"
  ]);
}, oe = "embeddedEs", Ci = [
  "js",
  "jsx",
  "es",
  "es6",
  "mjs",
  "cjs",
  "pac",
  "javascript"
], wi = [
  "babel",
  "babel-flow",
  "acorn",
  "espree",
  "flow",
  "meriyah"
], Fi = D(oe), Ke = A(oe), Je = T(oe), Wi = O(oe), zi = {
  [Fi]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ci] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded ECMAScript/JavaScript language.",
    deprecated: `Please use \`${Ke}\` or \`${Je}\`.`
  },
  [Ke]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded ECMAScript/JavaScript language."
  },
  [Je]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded ECMAScript/JavaScript language."
  },
  [Wi]: {
    category: "Embed",
    type: "choice",
    default: "babel",
    description: "The parser used to parse the embedded ECMASCript/JavaScript language.",
    choices: wi.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Ki = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Ri,
  language: oe,
  options: zi
}, Symbol.toStringTag, { value: "Module" })), { line: He, group: B, indent: Xe, softline: Qe } = M, Ji = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "glsl-parser"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return B([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [B(a)] : Xe([B(a)]),
      p,
      "`"
    ]);
  const h = c.length ? He : Qe, v = p.length ? He : Qe;
  return B([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, B(a)] : Xe([h, B(a)]),
    v,
    "`"
  ]);
}, be = "embeddedGlsl", Hi = ["glsl", "shader"], Xi = D(be), Ye = A(be), Ve = T(be), Qi = {
  [Xi]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Hi] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded GLSL language. This option requires the `prettier-plugin-glsl` plugin.",
    deprecated: `Please use \`${Ye}\` or \`${Ve}\`.`
  },
  [Ye]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded GLSL language. This option requires the `prettier-plugin-glsl` plugin."
  },
  [Ve]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded GLSL language. This option requires the `prettier-plugin-glsl` plugin."
  }
}, Yi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Ji,
  language: be,
  options: Qi
}, Symbol.toStringTag, { value: "Module" })), { line: Ze, group: q, indent: et, softline: tt } = M, Vi = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "graphql"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return q([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [q(a)] : et([q(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Ze : tt, v = p.length ? Ze : tt;
  return q([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, q(a)] : et([h, q(a)]),
    v,
    "`"
  ]);
}, fe = "embeddedGraphql", Zi = ["graphql", "gql"], es = D(fe), nt = A(fe), it = T(fe), ts = {
  [es]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Zi] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded GraphQL language.",
    deprecated: `Please use \`${nt}\` or \`${it}\`.`
  },
  [nt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded GraphQL language."
  },
  [it]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded GraphQL language."
  }
}, ns = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Vi,
  language: fe,
  options: ts
}, Symbol.toStringTag, { value: "Module" })), { line: st, group: j, indent: rt, softline: ot } = M, { mapDoc: is } = si, ss = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: i.embeddedHtmlParser ?? "html"
  }), a = is($, (m) => {
    if (typeof m != "string")
      return m;
    const g = [], y = m.split(E);
    for (let G = 0; G < y.length; G++) {
      let N = y[G];
      if (G % 2 === 0) {
        if (!N)
          continue;
        N = N.replaceAll(/([\\`]|\${)/g, "\\$1"), i.__embeddedInHtml && (N = N.replaceAll(/<\/(?=script\b)/gi, "<\\/")), g.push(N);
      } else {
        const x = Number(N);
        g.push(b[x]);
      }
    }
    return g;
  });
  if (i.htmlWhitespaceSensitivity === "strict" || // TODO: is css mode should be included here?
  i.htmlWhitespaceSensitivity === "css" || i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return j([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [j(a)] : rt([j(a)]),
      p,
      "`"
    ]);
  const h = c.length ? st : ot, v = p.length ? st : ot;
  return j([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, j(a)] : rt([h, j(a)]),
    v,
    "`"
  ]);
}, ae = "embeddedHtml", rs = ["html", "xhtml"], os = ["html", "vue", "angular", "lwc"], as = D(ae), at = A(ae), dt = T(ae), ds = O(ae), ls = {
  [as]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...rs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded HTML language.",
    deprecated: `Please use \`${at}\` or \`${dt}\`.`
  },
  [at]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded HTML language."
  },
  [dt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded HTML language."
  },
  [ds]: {
    category: "Embed",
    type: "choice",
    default: "html",
    description: "The parser used to parse the embedded HTML language.",
    choices: os.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, cs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ss,
  language: ae,
  options: ls
}, Symbol.toStringTag, { value: "Module" })), { line: lt, group: U, indent: ct, softline: ut } = M, us = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "ini"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return U([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [U(a)] : ct([U(a)]),
      p,
      "`"
    ]);
  const h = c.length ? lt : ut, v = p.length ? lt : ut;
  return U([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, U(a)] : ct([h, U(a)]),
    v,
    "`"
  ]);
}, ye = "embeddedIni", ps = ["ini", "cfg", "pro"], gs = D(ye), pt = A(ye), gt = T(ye), ms = {
  [gs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ps] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded INI language. This option requires the `prettier-plugin-ini` plugin.",
    deprecated: `Please use \`${pt}\` or \`${gt}\`.`
  },
  [pt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded INI language. This option requires the `prettier-plugin-ini` plugin."
  },
  [gt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded INI language. This option requires the `prettier-plugin-ini` plugin."
  }
}, hs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: us,
  language: ye,
  options: ms
}, Symbol.toStringTag, { value: "Module" })), { group: R, line: mt, softline: ht, indent: Et } = M, Es = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "java"
  }), a = S(
    $,
    E,
    b,
    !0
  );
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return R([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [R(a)] : Et([R(a)]),
      p,
      "`"
    ]);
  const h = c.length ? mt : ht, v = p.length ? mt : ht;
  return R([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, R(a)] : Et([h, R(a)]),
    v,
    "`"
  ]);
}, _e = "embeddedJava", bs = ["java"], fs = D(_e), bt = A(_e), ft = T(_e), ys = {
  [fs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...bs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Java language. This option requires the `prettier-plugin-java` plugin.",
    deprecated: `Please use \`${bt}\` or \`${ft}\`.`
  },
  [bt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Java language. This option requires the `prettier-plugin-java` plugin."
  },
  [ft]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Java language. This option requires the `prettier-plugin-java` plugin."
  }
}, _s = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Es,
  language: _e,
  options: ys
}, Symbol.toStringTag, { value: "Module" })), { line: yt, group: C, indent: _t, softline: $t } = M, $s = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = vs(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: i.embeddedJsonParser ?? "json"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return C([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [C(a)] : _t([C(a)]),
      p,
      "`"
    ]);
  const h = c.length ? yt : $t, v = p.length ? yt : $t;
  return C([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, C(a)] : _t([h, C(a)]),
    v,
    "`"
  ]);
};
function vs() {
  const e = he(), t = he(), n = (s) => `'0${e}${s}${t}'`, r = new RegExp(
    `["']?0${e}(\\d+)${t}['"]?`,
    "ig"
  );
  return {
    createPlaceholder: n,
    placeholderRegex: r
  };
}
const de = "embeddedJson", Ds = ["json", "jsonl"], Ts = ["json", "json5", "jsonc", "json-stringify"], Ms = D(de), vt = A(de), Dt = T(de), As = O(de), Ss = {
  [Ms]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ds] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded JSON language.",
    deprecated: `Please use \`${vt}\` or \`${Dt}\`.`
  },
  [vt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded JSON language."
  },
  [Dt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded JSON language."
  },
  [As]: {
    category: "Embed",
    type: "choice",
    default: "json",
    description: "The parser used to parse the embedded JSON language.",
    choices: Ts.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, ks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: $s,
  language: de,
  options: Ss
}, Symbol.toStringTag, { value: "Module" })), { line: Tt, group: w, indent: Mt, softline: At } = M, Ls = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L("$p"), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "JSONata"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return w([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [w(a)] : Mt([w(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Tt : At, v = p.length ? Tt : At;
  return w([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, w(a)] : Mt([h, w(a)]),
    v,
    "`"
  ]);
}, $e = "embeddedJsonata", Gs = ["jsonata"], Ns = D($e), St = A($e), kt = T($e), Os = {
  [Ns]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Gs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded JSONata language. This option requires the `@stedi/prettier-plugin-jsonata` plugin.",
    deprecated: `Please use \`${St}\` or \`${kt}\`.`
  },
  [St]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded JSONata language. This option requires the `@stedi/prettier-plugin-jsonata` plugin."
  },
  [kt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded JSONata language. This option requires the `@stedi/prettier-plugin-jsonata` plugin."
  }
}, xs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Ls,
  language: $e,
  options: Os
}, Symbol.toStringTag, { value: "Module" })), { line: Lt, group: F, indent: Gt, softline: Nt } = M, Is = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "latex-parser"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return F([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [F(a)] : Gt([F(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Lt : Nt, v = p.length ? Lt : Nt;
  return F([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, F(a)] : Gt([h, F(a)]),
    v,
    "`"
  ]);
}, ve = "embeddedLatex", Ps = [
  "latex",
  "tex",
  "aux",
  "cls",
  "bbl",
  "bib",
  "toc",
  "sty"
], Bs = D(ve), Ot = A(ve), xt = T(ve), qs = {
  [Bs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ps] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded LaTeX language. This option requires the `prettier-plugin-latex` plugin.",
    deprecated: `Please use \`${Ot}\` or \`${xt}\`.`
  },
  [Ot]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded LaTeX language. This option requires the `prettier-plugin-latex` plugin."
  },
  [xt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded LaTeX language. This option requires the `prettier-plugin-latex` plugin."
  }
}, js = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Is,
  language: ve,
  options: qs
}, Symbol.toStringTag, { value: "Module" }));
function It(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? It(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : It(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Us(e, t, n) {
  return t = Rs(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Rs(e) {
  var t = Cs(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function Cs(e, t) {
  if (typeof e != "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
const ri = oi({});
function oi(e) {
  return t.withOptions = (n) => oi(Pt(Pt({}, e), n)), t;
  function t(n, ...r) {
    const s = typeof n == "string" ? [n] : n.raw, {
      escapeSpecialCharacters: o = Array.isArray(n)
    } = e;
    let i = "";
    for (let E = 0; E < s.length; E++) {
      let d = s[E];
      o && (d = d.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{")), i += d, E < r.length && (i += r[E]);
    }
    const l = i.split(`
`);
    let u = null;
    for (const E of l) {
      const d = E.match(/^(\s+)\S+/);
      if (d) {
        const c = d[1].length;
        u ? u = Math.min(u, c) : u = c;
      }
    }
    if (u !== null) {
      const E = u;
      i = l.map((d) => d[0] === " " || d[0] === "	" ? d.slice(E) : d).join(`
`);
    }
    return i = i.trim(), o && (i = i.replace(/\\n/g, `
`)), i;
  }
}
const { line: Bt, group: W, indent: qt, softline: jt } = M, ws = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(
    // use `dedent` to fix unstable embedded markdown indentation with the `useTabs` option
    // https://github.com/Sec-ant/prettier-plugin-embed/pull/91#issuecomment-1963760555
    // https://github.com/prettier/prettier/blob/1079517b32e5bb145afa7acba448af51f8a7b6e6/src/language-js/embed/markdown.js#L15-L19
    ri(f),
    {
      ...i,
      parser: i.embeddedMarkdownParser ?? "markdown",
      // this will change the code fence delimiter from ``` to ~~~
      // https://github.com/prettier/prettier/blob/1079517b32e5bb145afa7acba448af51f8a7b6e6/src/language-markdown/embed.js#L15
      __inJsTemplate: !0
    }
  ), a = S(
    $,
    E,
    b,
    !0
  );
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return W([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [W(a)] : qt([W(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Bt : jt, v = p.length ? Bt : jt;
  return W([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, W(a)] : qt([h, W(a)]),
    v,
    "`"
  ]);
}, le = "embeddedMarkdown", Fs = ["md", "markdown"], Ws = ["markdown", "mdx", "remark"], zs = D(le), Ut = A(le), Rt = T(le), Ks = O(le), Js = {
  [zs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Fs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Markdown language.",
    deprecated: `Please use \`${Ut}\` or \`${Rt}\`.`
  },
  [Ut]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Markdown language."
  },
  [Rt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Markdown language."
  },
  [Ks]: {
    category: "Embed",
    type: "choice",
    default: "markdown",
    description: "The parser used to parse the embedded Markdown language.",
    choices: Ws.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Hs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ws,
  language: le,
  options: Js
}, Symbol.toStringTag, { value: "Module" })), { line: Ct, group: z, indent: wt, softline: Ft } = M, Xs = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "nginx"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return z([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [z(a)] : wt([z(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Ct : Ft, v = p.length ? Ct : Ft;
  return z([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, z(a)] : wt([h, z(a)]),
    v,
    "`"
  ]);
}, De = "embeddedNginx", Qs = ["nginx"], Ys = D(De), Wt = A(De), zt = T(De), Vs = {
  [Ys]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Qs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded NGINX language. This option requires the `prettier-plugin-nginx` plugin.",
    deprecated: `Please use \`${Wt}\` or \`${zt}\`.`
  },
  [Wt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded NGINX language. This option requires the `prettier-plugin-nginx` plugin."
  },
  [zt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded NGINX language. This option requires the `prettier-plugin-nginx` plugin."
  }
}, Zs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Xs,
  language: De,
  options: Vs
}, Symbol.toStringTag, { value: "Module" })), ce = "embeddedNoop", er = D(ce), Kt = A(ce), Jt = T(ce), tr = {
  [er]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tag or comment identifiers that prevent their subsequent template literals from being identified as embedded languages and thus from being formatted.",
    deprecated: `Please use \`${Kt}\` or \`${Jt}\`.`
  },
  [Kt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that prevent their subsequent template literals from being identified as embedded languages and thus from being formatted."
  },
  [Jt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that prevent their subsequent template literals from being identified as embedded languages and thus from being formatted."
  }
}, nr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  language: ce,
  options: tr
}, Symbol.toStringTag, { value: "Module" })), { line: Ht, group: K, indent: Xt, softline: Qt } = M, ir = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "pegjs-parser"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return K([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [K(a)] : Xt([K(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Ht : Qt, v = p.length ? Ht : Qt;
  return K([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, K(a)] : Xt([h, K(a)]),
    v,
    "`"
  ]);
}, Te = "embeddedPegjs", sr = ["pegjs", "peggy", "peg"], rr = D(Te), Yt = A(Te), Vt = T(Te), or = {
  [rr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...sr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Pegjs language. This option requires the `prettier-plugin-pegjs` plugin.",
    deprecated: `Please use \`${Yt}\` or \`${Vt}\`.`
  },
  [Yt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Pegjs language. This option requires the `prettier-plugin-pegjs` plugin."
  },
  [Vt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Pegjs language. This option requires the `prettier-plugin-pegjs` plugin."
  }
}, ar = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ir,
  language: Te,
  options: or
}, Symbol.toStringTag, { value: "Module" })), { line: Zt, group: J, indent: en, softline: tn } = M, dr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L("$p"), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "php"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return J([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [J(a)] : en([J(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Zt : tn, v = p.length ? Zt : tn;
  return J([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, J(a)] : en([h, J(a)]),
    v,
    "`"
  ]);
}, Me = "embeddedPhp", lr = ["php", "php5"], cr = D(Me), nn = A(Me), sn = T(Me), ur = {
  [cr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...lr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded PHP language. This option requires the `@prettier/plugin-php` plugin.",
    deprecated: `Please use \`${nn}\` or \`${sn}\`.`
  },
  [nn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded PHP language. This option requires the `@prettier/plugin-php` plugin."
  },
  [sn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded PHP language. This option requires the `@prettier/plugin-php` plugin."
  }
}, pr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: dr,
  language: Me,
  options: ur
}, Symbol.toStringTag, { value: "Module" })), { line: rn, group: H, indent: on, softline: an } = M, gr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "prisma-parse"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return H([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [H(a)] : on([H(a)]),
      p,
      "`"
    ]);
  const h = c.length ? rn : an, v = p.length ? rn : an;
  return H([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, H(a)] : on([h, H(a)]),
    v,
    "`"
  ]);
}, Ae = "embeddedPrisma", mr = ["prisma"], hr = D(Ae), dn = A(Ae), ln = T(Ae), Er = {
  [hr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...mr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Prisma language. This option requires the `prettier-plugin-prisma` plugin.",
    deprecated: `Please use \`${dn}\` or \`${ln}\`.`
  },
  [dn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Prisma language. This option requires the `prettier-plugin-prisma` plugin."
  },
  [ln]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Prisma language. This option requires the `prettier-plugin-prisma` plugin."
  }
}, br = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: gr,
  language: Ae,
  options: Er
}, Symbol.toStringTag, { value: "Module" })), { line: cn, group: X, indent: un, softline: pn } = M, fr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "dot-properties"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return X([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [X(a)] : un([X(a)]),
      p,
      "`"
    ]);
  const h = c.length ? cn : pn, v = p.length ? cn : pn;
  return X([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, X(a)] : un([h, X(a)]),
    v,
    "`"
  ]);
}, Se = "embeddedProperties", yr = ["properties"], _r = D(Se), gn = A(Se), mn = T(Se), $r = {
  [_r]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...yr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Properties language. This option requires the `prettier-plugin-properties` plugin.",
    deprecated: `Please use \`${gn}\` or \`${mn}\`.`
  },
  [gn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Properties language. This option requires the `prettier-plugin-properties` plugin."
  },
  [mn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Properties language. This option requires the `prettier-plugin-properties` plugin."
  }
}, vr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: fr,
  language: Se,
  options: $r
}, Symbol.toStringTag, { value: "Module" })), { group: Q, line: hn, softline: En, indent: bn } = M, Dr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "pug"
  }), a = S(
    $,
    E,
    b,
    !0
  );
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return Q([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [Q(a)] : bn([Q(a)]),
      p,
      "`"
    ]);
  const h = c.length ? hn : En, v = p.length ? hn : En;
  return Q([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, Q(a)] : bn([h, Q(a)]),
    v,
    "`"
  ]);
}, ke = "embeddedPug", Tr = ["pug", "jade"], Mr = D(ke), fn = A(ke), yn = T(ke), Ar = {
  [Mr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Tr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Pug language. This option requires the `@prettier/plugin-pug` plugin.",
    deprecated: `Please use \`${fn}\` or \`${yn}\`.`
  },
  [fn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Pug language. This option requires the `@prettier/plugin-pug` plugin."
  },
  [yn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Pug language. This option requires the `@prettier/plugin-pug` plugin."
  }
}, Sr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Dr,
  language: ke,
  options: Ar
}, Symbol.toStringTag, { value: "Module" })), { line: _n, group: Y, indent: $n, softline: vn } = M, kr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: i.embeddedRubyParser ?? "ruby"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return Y([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [Y(a)] : $n([Y(a)]),
      p,
      "`"
    ]);
  const h = c.length ? _n : vn, v = p.length ? _n : vn;
  return Y([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, Y(a)] : $n([h, Y(a)]),
    v,
    "`"
  ]);
}, ue = "embeddedRuby", Lr = ["ruby"], Gr = ["ruby", "rbs", "haml"], Nr = D(ue), Dn = A(ue), Tn = T(ue), Or = O(ue), xr = {
  [Nr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Lr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin.",
    deprecated: `Please use \`${Dn}\` or \`${Tn}\`.`
  },
  [Dn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin."
  },
  [Tn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin."
  },
  [Or]: {
    category: "Embed",
    type: "choice",
    default: "ruby",
    description: "The parser used to parse the embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin.",
    choices: Gr.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Ir = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: kr,
  language: ue,
  options: xr
}, Symbol.toStringTag, { value: "Module" })), { group: V, line: Mn, softline: An, indent: Sn } = M, Pr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "sh"
  }), a = S(
    $,
    E,
    b,
    !0
  );
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return V([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [V(a)] : Sn([V(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Mn : An, v = p.length ? Mn : An;
  return V([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, V(a)] : Sn([h, V(a)]),
    v,
    "`"
  ]);
}, Le = "embeddedSh", Br = ["sh"], qr = D(Le), kn = A(Le), Ln = T(Le), jr = {
  [qr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Br] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Shell language. This option requires the `prettier-plugin-sh` plugin.",
    deprecated: `Please use \`${kn}\` or \`${Ln}\`.`
  },
  [kn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Shell language. This option requires the `prettier-plugin-sh` plugin."
  },
  [Ln]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded Shell language. This option requires the `prettier-plugin-sh` plugin."
  }
}, Ur = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Pr,
  language: Le,
  options: jr
}, Symbol.toStringTag, { value: "Module" })), { group: Z, line: Gn, softline: Nn, indent: On } = M, Rr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, l = i.embeddedSqlPlugin ?? "prettier-plugin-sql", { node: u } = n, { createPlaceholder: E, placeholderRegex: d } = L(), c = u.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + E(g)
  ).join(""), p = c.match(/^\s+/)?.[0] ?? "", f = c.match(/\s+$/)?.[0] ?? "", b = c.slice(
    p.length,
    -f.length || void 0
  ), $ = k(n, t);
  let a;
  if (l === "prettier-plugin-sql-cst") {
    const m = await e(b, {
      ...i,
      parser: i.embeddedSqlParser ?? "sqlite"
    });
    a = S(m, d, $);
  } else {
    const m = await e(ri(b), {
      ...i,
      parser: "sql"
    });
    a = S(
      m,
      d,
      $,
      !0
    );
  }
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return Z([
      "`",
      p,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [Z(a)] : On([Z(a)]),
      f,
      "`"
    ]);
  const h = p.length ? Gn : Nn, v = f.length ? Gn : Nn;
  return Z([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, Z(a)] : On([h, Z(a)]),
    v,
    "`"
  ]);
}, se = "embeddedSql", Cr = ["sql"], wr = ["prettier-plugin-sql", "prettier-plugin-sql-cst"], Fr = [
  "sqlite",
  "bigquery",
  "mysql",
  "mariadb",
  "postgresql"
], Wr = D(se), xn = A(se), In = T(se), zr = Oi(se), Kr = O(se), Jr = {
  [Wr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Cr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin.",
    deprecated: `Please use \`${xn}\` or \`${In}\`.`
  },
  [xn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin."
  },
  [In]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin."
  },
  [zr]: {
    category: "Embed",
    type: "choice",
    default: "prettier-plugin-sql",
    description: "The plugin used to format the embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin.",
    choices: wr.map((e) => ({
      value: e,
      description: `Use the "${e}" plugin.`
    }))
  },
  [Kr]: {
    category: "Embed",
    type: "choice",
    default: "sqlite",
    description: "Specify the embedded SQL language parser. This option is only needed with the `prettier-plugin-sql-cst` plugin.",
    choices: Fr.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Hr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Rr,
  language: se,
  options: Jr
}, Symbol.toStringTag, { value: "Module" })), { line: Pn, group: ee, indent: Bn, softline: qn } = M, Xr = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "toml"
  }), a = S(
    $,
    E,
    b,
    !0
  );
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return ee([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [ee(a)] : Bn([ee(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Pn : qn, v = p.length ? Pn : qn;
  return ee([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, ee(a)] : Bn([h, ee(a)]),
    v,
    "`"
  ]);
}, Ge = "embeddedToml", Qr = ["toml"], Yr = D(Ge), jn = A(Ge), Un = T(Ge), Vr = {
  [Yr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Qr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded TOML language. This option requires the `prettier-plugin-toml` plugin.",
    deprecated: `Please use \`${jn}\` or \`${Un}\`.`
  },
  [jn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded TOML language. This option requires the `prettier-plugin-toml` plugin."
  },
  [Un]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded TOML language. This option requires the `prettier-plugin-toml` plugin."
  }
}, Zr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Xr,
  language: Ge,
  options: Vr
}, Symbol.toStringTag, { value: "Module" })), { line: Rn, group: te, indent: Cn, softline: wn } = M, eo = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: i.embeddedTsParser ?? "typescript",
    // set filepath to undefined to enable jsx auto detection:
    // https://github.com/prettier/prettier/blob/427a84d24203e2d54160cde153a1e6a6390fe65a/src/language-js/parse/typescript.js#L49-L53
    filepath: void 0
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return te([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [te(a)] : Cn([te(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Rn : wn, v = p.length ? Rn : wn;
  return te([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, te(a)] : Cn([h, te(a)]),
    v,
    "`"
  ]);
}, pe = "embeddedTs", to = [
  "ts",
  "tsx",
  "cts",
  "mts",
  "typescript"
], no = ["typescript", "babel-ts"], io = D(pe), Fn = A(pe), Wn = T(pe), so = O(pe), ro = {
  [io]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...to] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded TypeScript language.",
    deprecated: `Please use \`${Fn}\` or \`${Wn}\`.`
  },
  [Fn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded TypeScript language."
  },
  [Wn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded TypeScript language."
  },
  [so]: {
    category: "Embed",
    type: "choice",
    default: "typescript",
    description: "The parser used to parse the embedded TypeScript language.",
    choices: no.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, oo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: eo,
  language: pe,
  options: ro
}, Symbol.toStringTag, { value: "Module" })), ge = "embeddedXml", { line: zn, group: ne, indent: Kn, softline: Oe } = M, ao = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (g, y, { length: G }) => y === G - 1 ? g.value.cooked : g.value.cooked + u(y)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = [];
  let a = 0;
  for (; a !== void 0; ) {
    const g = f.slice(a);
    if (g.length === 0)
      break;
    a > 0 && i.xmlWhitespaceSensitivity !== "strict" && $.push(Oe), i.__embeddedXmlFragmentRecoverIndex?.splice(
      0,
      i.__embeddedXmlFragmentRecoverIndex.length
    );
    let y = await e(g, {
      ...i,
      parser: ge
    });
    const [G, N] = i.__embeddedXmlFragmentRecoverIndex ?? [];
    G === void 0 ? a = void 0 : N === void 0 ? a += G : (y = g.slice(G, N + 1), a += N + 1), $.push(y);
  }
  const h = S($, E, b);
  if (i.xmlWhitespaceSensitivity === "strict" || i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return ne([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [ne(h)] : Kn([ne(h)]),
      p,
      "`"
    ]);
  const v = c.length ? zn : Oe, m = p.length ? zn : Oe;
  return ne([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [v, ne(h)] : Kn([v, ne(h)]),
    m,
    "`"
  ]);
}, lo = ["xml", "opml", "rss", "svg"], co = D(ge), Jn = A(ge), Hn = T(ge), uo = {
  [co]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...lo] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded XML language. This option requires the `@prettier/plugin-xml` plugin.",
    deprecated: `Please use \`${Jn}\` or \`${Hn}\`.`
  },
  [Jn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded XML language. This option requires the `@prettier/plugin-xml` plugin."
  },
  [Hn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded XML language. This option requires the `@prettier/plugin-xml` plugin."
  },
  /**
   * @internal
   */
  __embeddedXmlFragmentRecoverIndex: {
    category: "Embed",
    type: "int",
    array: !0,
    default: [{ value: [] }],
    description: "This option is read only and is used internally as a workaround to support xml fragments"
  }
};
function po(e) {
  const t = {
    loc: {
      start: {
        line: e.line,
        column: e.column
      },
      end: {
        line: e.line,
        column: e.column + e.length
      }
    }
  }, n = new SyntaxError(
    `${e.message} (${t.loc.start.line}:${t.loc.start.column})`,
    {
      cause: e
    }
  );
  return Object.assign(n, t), n;
}
function Xn(e) {
  const t = {
    loc: {
      start: {
        line: e.token.startLine ?? Number.NaN,
        column: e.token.startColumn ?? Number.NaN
      },
      end: {
        line: e.token.endLine ?? Number.NaN,
        column: e.token.endColumn ?? Number.NaN
      }
    }
  }, n = new SyntaxError(
    `${e.message} (${t.loc.start.line}:${t.loc.start.column})`,
    {
      cause: e
    }
  );
  return Object.assign(n, t), n;
}
const go = {
  async parse(e, t) {
    const { parse: n } = await import("@xml-tools/parser"), { lexErrors: r, parseErrors: s, cst: o } = n(e);
    if (r.length > 0) {
      const i = r[0];
      throw po(i);
    }
    if (s.length > 0) {
      let i = !1;
      for (const l of s) {
        if (!["MismatchedTokenException", "NotAllInputParsedException"].includes(
          l.name
        ))
          throw Xn(l);
        if (l.message === "Expecting token of type --> OPEN <-- but found --> '' <--") {
          i = !0;
          continue;
        }
        if (/Expecting token of type --> EOF <-- but found --> '[\s\S]+' <--/.test(
          l.message
        ) || /Redundant input, expecting EOF but found: /.test(l.message)) {
          t.__embeddedXmlFragmentRecoverIndex?.splice(
            0,
            t.__embeddedXmlFragmentRecoverIndex.length,
            l.token.startOffset
          );
          break;
        }
        if (/Expecting token of type --> OPEN <-- but found --> '[\s\S]+' <--/.test(
          l.message
        )) {
          if (l.token.endOffset === void 0 || Number.isNaN(l.token.endOffset))
            break;
          t.__embeddedXmlFragmentRecoverIndex?.splice(
            0,
            t.__embeddedXmlFragmentRecoverIndex.length,
            l.token.startOffset,
            l.token.endOffset
          ), i = !0;
          break;
        }
        throw Xn(l);
      }
      i && ai(o);
    }
    return o;
  },
  astFormat: "xml",
  locStart(e) {
    return e.location.startOffset;
  },
  locEnd(e) {
    return e.location.endOffset ?? Number.NaN;
  }
};
function ai(e) {
  const t = e.children;
  for (const n in t) {
    const r = t[n] ?? [];
    for (let s = r.length - 1; s >= 0; --s) {
      const o = r[s];
      if (mo(o)) {
        if (Object.keys(o.children).length === 0) {
          r.splice(s, 1), r.length === 0 && delete t[n];
          continue;
        }
        ai(o);
      }
    }
  }
}
function mo(e) {
  return "name" in e && "children" in e && "location" in e;
}
const ho = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ao,
  language: ge,
  options: uo,
  parser: go
}, Symbol.toStringTag, { value: "Module" })), { line: Qn, group: ie, indent: Yn, softline: Vn } = M, Eo = async (e, t, n, r, { commentOrTag: s, embeddedOverrideOptions: o }) => {
  const i = {
    ...r,
    ...o
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = k(n, t), $ = await e(f, {
    ...i,
    parser: "yaml"
  }), a = S($, E, b);
  if (i.preserveEmbeddedExteriorWhitespaces?.includes(s))
    return ie([
      "`",
      c,
      i.noEmbeddedMultiLineIndentation?.includes(s) ? [ie(a)] : Yn([ie(a)]),
      p,
      "`"
    ]);
  const h = c.length ? Qn : Vn, v = p.length ? Qn : Vn;
  return ie([
    "`",
    i.noEmbeddedMultiLineIndentation?.includes(s) ? [h, ie(a)] : Yn([h, ie(a)]),
    v,
    "`"
  ]);
}, Ne = "embeddedYaml", bo = ["yaml", "yml"], fo = D(Ne), Zn = A(Ne), ei = T(Ne), yo = {
  [fo]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...bo] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded YAML language.",
    deprecated: `Please use \`${Zn}\` or \`${ei}\`.`
  },
  [Zn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Block comments that make their subsequent template literals be identified as embedded YAML language."
  },
  [ei]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [_] }],
    description: "Tags that make their subsequent template literals be identified as embedded YAML language."
  }
}, _o = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Eo,
  language: Ne,
  options: yo
}, Symbol.toStringTag, { value: "Module" })), me = [], di = {}, li = {}, ci = {}, $o = /* @__PURE__ */ Object.assign({
  "./css/index.ts": Ui,
  "./es/index.ts": Ki,
  "./glsl/index.ts": Yi,
  "./graphql/index.ts": ns,
  "./html/index.ts": cs,
  "./ini/index.ts": hs,
  "./java/index.ts": _s,
  "./json/index.ts": ks,
  "./jsonata/index.ts": xs,
  "./latex/index.ts": js,
  "./markdown/index.ts": Hs,
  "./nginx/index.ts": Zs,
  "./noop/index.ts": nr,
  "./pegjs/index.ts": ar,
  "./php/index.ts": pr,
  "./prisma/index.ts": br,
  "./properties/index.ts": vr,
  "./pug/index.ts": Sr,
  "./ruby/index.ts": Ir,
  "./sh/index.ts": Ur,
  "./sql/index.ts": Hr,
  "./toml/index.ts": Zr,
  "./ts/index.ts": oo,
  "./xml/index.ts": ho,
  "./yaml/index.ts": _o
});
for (const { language: e, parser: t, embedder: n, options: r } of Object.values($o))
  Ni(me, e, ce), t && (di[e] = t), n && (li[e] = n), Object.assign(ci, r);
const vo = "noEmbeddedIdentificationByComment", Do = "noEmbeddedIdentificationByTag", To = "preserveEmbeddedExteriorWhitespaces", Mo = "noEmbeddedMultiLineIndentation", Ao = "embeddedOverrides", sa = {
  ...ci,
  /**
   * @deprecated Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore.
   */
  [vo]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Turns off `` /* comment */ `...` `` comment-based embedded language identification for the specified identifiers.",
    deprecated: "Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore."
  },
  /**
   * @deprecated Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore.
   */
  [Do]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Turns off `` tag`...` `` tag-based embedded language identification for the specified identifiers.",
    deprecated: "Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore."
  },
  [To]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Preserves leading and trailing whitespaces in the formatting results for the specified comments or tags."
  },
  [Mo]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Turns off auto indentation in the formatting results for the specified comments or tags when they are formatted to span multi lines."
  },
  [Ao]: {
    category: "Embed",
    type: "string",
    array: !1,
    default: void 0,
    description: "Option overrides for the specified comments or tags. It should either be a stringified JSON or an absolute filepath to the option overrides file."
  }
}, So = {
  // parsers from internal
  ...fi.parsers,
  ...yi.parsers,
  ..._i.parsers,
  ...vi.parsers,
  ...$i.parsers,
  // parsers from this plugin
  ...di
};
var ko = {
  isEqual: !0,
  isMatchingKey: !0,
  isPromise: !0,
  maxSize: !0,
  onCacheAdd: !0,
  onCacheChange: !0,
  onCacheHit: !0,
  transformKey: !0
}, Lo = Array.prototype.slice;
function Ee(e) {
  var t = e.length;
  return t ? t === 1 ? [e[0]] : t === 2 ? [e[0], e[1]] : t === 3 ? [e[0], e[1], e[2]] : Lo.call(e, 0) : [];
}
function Go(e) {
  var t = {};
  for (var n in e)
    ko[n] || (t[n] = e[n]);
  return t;
}
function No(e) {
  return typeof e == "function" && e.isMemoized;
}
function Oo(e, t) {
  return e === t || e !== e && t !== t;
}
function ti(e, t) {
  var n = {};
  for (var r in e)
    n[r] = e[r];
  for (var r in t)
    n[r] = t[r];
  return n;
}
var xo = (
  /** @class */
  function() {
    function e(t) {
      this.keys = [], this.values = [], this.options = t;
      var n = typeof t.isMatchingKey == "function";
      n ? this.getKeyIndex = this._getKeyIndexFromMatchingKey : t.maxSize > 1 ? this.getKeyIndex = this._getKeyIndexForMany : this.getKeyIndex = this._getKeyIndexForSingle, this.canTransformKey = typeof t.transformKey == "function", this.shouldCloneArguments = this.canTransformKey || n, this.shouldUpdateOnAdd = typeof t.onCacheAdd == "function", this.shouldUpdateOnChange = typeof t.onCacheChange == "function", this.shouldUpdateOnHit = typeof t.onCacheHit == "function";
    }
    return Object.defineProperty(e.prototype, "size", {
      /**
       * The number of cached [key,value] results.
       */
      get: function() {
        return this.keys.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "snapshot", {
      /**
       * A copy of the cache at a moment in time. This is useful
       * to compare changes over time, since the cache mutates
       * internally for performance reasons.
       */
      get: function() {
        return {
          keys: Ee(this.keys),
          size: this.size,
          values: Ee(this.values)
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype._getKeyIndexFromMatchingKey = function(t) {
      var n = this.options, r = n.isMatchingKey, s = n.maxSize, o = this.keys, i = o.length;
      if (!i)
        return -1;
      if (r(o[0], t))
        return 0;
      if (s > 1) {
        for (var l = 1; l < i; l++)
          if (r(o[l], t))
            return l;
      }
      return -1;
    }, e.prototype._getKeyIndexForMany = function(t) {
      var n = this.options.isEqual, r = this.keys, s = r.length;
      if (!s)
        return -1;
      if (s === 1)
        return this._getKeyIndexForSingle(t);
      var o = t.length, i, l;
      if (o > 1) {
        for (var u = 0; u < s; u++)
          if (i = r[u], i.length === o) {
            for (l = 0; l < o && n(i[l], t[l]); l++)
              ;
            if (l === o)
              return u;
          }
      } else
        for (var u = 0; u < s; u++)
          if (i = r[u], i.length === o && n(i[0], t[0]))
            return u;
      return -1;
    }, e.prototype._getKeyIndexForSingle = function(t) {
      var n = this.keys;
      if (!n.length)
        return -1;
      var r = n[0], s = r.length;
      if (t.length !== s)
        return -1;
      var o = this.options.isEqual;
      if (s > 1) {
        for (var i = 0; i < s; i++)
          if (!o(r[i], t[i]))
            return -1;
        return 0;
      }
      return o(r[0], t[0]) ? 0 : -1;
    }, e.prototype.orderByLru = function(t, n, r) {
      for (var s = this.keys, o = this.values, i = s.length, l = r; l--; )
        s[l + 1] = s[l], o[l + 1] = o[l];
      s[0] = t, o[0] = n;
      var u = this.options.maxSize;
      i === u && r === i ? (s.pop(), o.pop()) : r >= u && (s.length = o.length = u);
    }, e.prototype.updateAsyncCache = function(t) {
      var n = this, r = this.options, s = r.onCacheChange, o = r.onCacheHit, i = this.keys[0], l = this.values[0];
      this.values[0] = l.then(function(u) {
        return n.shouldUpdateOnHit && o(n, n.options, t), n.shouldUpdateOnChange && s(n, n.options, t), u;
      }, function(u) {
        var E = n.getKeyIndex(i);
        throw E !== -1 && (n.keys.splice(E, 1), n.values.splice(E, 1)), u;
      });
    }, e;
  }()
);
function ui(e, t) {
  if (t === void 0 && (t = {}), No(e))
    return ui(e.fn, ti(e.options, t));
  if (typeof e != "function")
    throw new TypeError("You must pass a function to `memoize`.");
  var n = t.isEqual, r = n === void 0 ? Oo : n, s = t.isMatchingKey, o = t.isPromise, i = o === void 0 ? !1 : o, l = t.maxSize, u = l === void 0 ? 1 : l, E = t.onCacheAdd, d = t.onCacheChange, c = t.onCacheHit, p = t.transformKey, f = ti({
    isEqual: r,
    isMatchingKey: s,
    isPromise: i,
    maxSize: u,
    onCacheAdd: E,
    onCacheChange: d,
    onCacheHit: c,
    transformKey: p
  }, Go(t)), b = new xo(f), $ = b.keys, a = b.values, h = b.canTransformKey, v = b.shouldCloneArguments, m = b.shouldUpdateOnAdd, g = b.shouldUpdateOnChange, y = b.shouldUpdateOnHit, G = function() {
    var N = v ? Ee(arguments) : arguments;
    h && (N = p(N));
    var x = $.length ? b.getKeyIndex(N) : -1;
    if (x !== -1)
      y && c(b, f, G), x && (b.orderByLru($[x], a[x], x), g && d(b, f, G));
    else {
      var Ei = e.apply(this, arguments), bi = v ? N : Ee(arguments);
      b.orderByLru(bi, Ei, $.length), i && b.updateAsyncCache(G), m && E(b, f, G), g && d(b, f, G);
    }
    return a[0];
  };
  return G.cache = b, G.fn = e, G.isMemoized = !0, G.options = f, G;
}
const Io = /("(?:\\?[^])*?")|(\/\/.*)|(\/\*[^]*?\*\/)/g, Po = /("(?:\\?[^])*?")|(,\s*)(?=]|})/g, Pe = {
  parse: (e) => {
    e = String(e);
    try {
      return JSON.parse(e);
    } catch {
      return JSON.parse(e.replace(Io, "$1").replace(Po, "$1"));
    }
  }
}, { label: Bo } = M;
async function ni(e) {
  try {
    const { readFile: t } = await import("node:fs/promises"), n = await t(e, { encoding: "utf-8" });
    return Pe.parse(n);
  } catch {
  }
}
const qo = /* @__PURE__ */ new URL(
  `data:text/javascript,${encodeURIComponent('import{pathToFileURL as o}from"node:url";import{parentPort as t,workerData as a}from"node:worker_threads";const s=async({absolutePath:r})=>{try{const e=await import(o(r).href);t?.postMessage(e.embeddedOverrides??e.default??void 0)}catch{t?.postMessage(void 0)}};s(a);')}`
), jo = /* @__PURE__ */ new URL(
  `data:text/javascript,${encodeURIComponent('import{register as a}from"node:module";import{pathToFileURL as s}from"node:url";import{parentPort as t,workerData as i}from"node:worker_threads";const d=async({absolutePath:r,importMetaUrl:o})=>{a("tsx/esm",{parentURL:o,data:!0});try{const e=await import(s(r).href);t?.postMessage(e.embeddedOverrides??e.default??void 0)}catch{t?.postMessage(void 0)}};d(i);')}`
);
async function Uo(e) {
  const { Worker: t } = await import("node:worker_threads");
  return new Promise((n) => {
    const r = new t(qo, {
      workerData: {
        absolutePath: e
      }
    });
    r.once("message", (s) => {
      n(s);
    }), r.once("error", (s) => {
      console.error(s), n(void 0);
    });
  });
}
async function Ro(e) {
  const { Worker: t } = await import("node:worker_threads");
  return new Promise((n) => {
    const r = new t(jo, {
      workerData: {
        absolutePath: e,
        importMetaUrl: import.meta.url
      }
    });
    r.once("message", (s) => {
      n(s);
    }), r.once("error", (s) => {
      console.error(s), n(void 0);
    });
  });
}
const Co = ui(
  async (e, t) => {
    const { isAbsolute: n, dirname: r, resolve: s } = await import("node:path");
    if (n(e))
      return e;
    const o = await Ti(t);
    let i;
    return typeof o != "string" ? i = process.env.PWD ?? process.cwd() : i = r(o), s(i, e);
  }
), wo = async (e, t) => {
  let n;
  try {
    n = (await import("node:path")).extname(
      e
    );
  } catch {
    try {
      return Pe.parse(e);
    } catch {
      console.error("Failed to parse embeddedOverrides as a json object");
      return;
    }
  }
  const r = Co(
    e,
    t
  );
  if (n === ".json" || n === ".jsonc") {
    const s = await r, o = await ni(s);
    if (o !== void 0)
      return o;
    console.error(`Failed to parse the json file: ${s}`);
    return;
  }
  if (n === ".mjs" || n === ".cjs" || n === ".js") {
    const s = await r, o = await Uo(s);
    if (o !== void 0)
      return o;
    console.error(`Failed to parse the js module file: ${s}`);
    return;
  }
  if (n === ".mts" || n === ".cts" || n === ".ts") {
    const s = await r, o = await Ro(s);
    if (o !== void 0)
      return o;
    console.error(`Failed to parse the ts module file: ${s}`);
    return;
  }
  if (n === "") {
    const s = await r, o = await ni(s);
    if (o !== void 0)
      return o;
  }
  try {
    return Pe.parse(e);
  } catch {
    console.error("Failed to parse embeddedOverrides as a json object");
  }
};
async function Fo(e, {
  commentOrTag: t,
  kind: n,
  filepath: r
}) {
  if (e === void 0)
    return;
  const s = await wo(
    e,
    r
  );
  if (s !== void 0)
    for (const {
      [`${n}s`]: o,
      identifiers: i,
      options: l
    } of s) {
      const u = o ?? [];
      if (u.length === 0 && i?.includes(t) || u.includes(t))
        return l;
    }
}
function* pi(e) {
  yield e, e.type === "CallExpression" && (yield* pi(e.callee));
}
const Wo = /* @__PURE__ */ (() => {
  const e = /* @__PURE__ */ new Set([
    "start",
    "end",
    "loc",
    "range",
    "filename",
    "typeAnnotation",
    "decorators"
  ]);
  return (t, n, r) => {
    let s;
    try {
      const i = r(`${n}\`\``);
      if (i instanceof Promise)
        throw new TypeError("Async parse function hasn't been supported yet.");
      s = i;
    } catch {
      return !1;
    }
    if (s.type === "File" && (s = s.program), !(s.type === "Program" && s.body[0]?.type === "ExpressionStatement"))
      return !1;
    const o = s.body[0]?.expression;
    if (o?.type !== "TaggedTemplateExpression")
      return !1;
    for (const i of pi(t))
      if (mi(
        i,
        o.tag,
        e
      ))
        return !0;
    return !1;
  };
})();
function zo({
  node: e,
  parent: t
}) {
  const n = e.comments ?? t?.comments;
  if (!n)
    return;
  const r = n[n.length - 1];
  if (![
    "MultiLine",
    // meriyah
    "Block",
    // typescript, acorn, espree, flow
    "CommentBlock"
    // babel, babel-flow, babel-ts
  ].includes(r.type) || !r.leading)
    return;
  const s = r.value;
  if (s.length > 1 && s.startsWith(" ") && s.endsWith(" "))
    return s.slice(1, -1);
}
function Ko({
  parent: e
}) {
  if (e?.type === "TaggedTemplateExpression")
    return e.tag.type === "Identifier" ? e.tag.name : e.tag;
}
function Jo(e, t) {
  return e.noEmbeddedIdentificationByComment?.includes(t) ?? !1 ? function* (r) {
  } : function* (r) {
    const s = e[A(r)] ?? [_];
    s[0] === _ ? yield* e[D(r)] ?? [] : yield* s ?? [];
  };
}
function ii(e, t) {
  return typeof t == "string" ? e.noEmbeddedIdentificationByTag?.includes(t) ?? !1 ? function* (r) {
  } : function* (r) {
    const s = e[T(r)] ?? [
      _
    ];
    s[0] === _ ? yield* e[D(r)] ?? [] : yield* s ?? [];
  } : function* (n) {
    const r = e[T(n)] ?? [
      _
    ];
    if (r[0] === _) {
      const { noEmbeddedIdentificationByTag: s } = e;
      for (const o of e[D(n)] ?? [])
        s?.includes(o) || (yield o);
    } else
      yield* r;
  };
}
function xe(e, t, n, r, s) {
  const o = li[t];
  if (!o)
    return null;
  if (e.quasis.length === 1 && e.quasis[0]?.value.raw.trim() === "")
    return "``";
  const i = Fo(
    s.embeddedOverrides,
    {
      commentOrTag: n,
      kind: r,
      filepath: s.filepath
    }
  );
  return async (...l) => {
    try {
      const u = await o(...l, {
        commentOrTag: n,
        kind: r,
        embeddedOverrideOptions: await i
      });
      return Bo(
        {
          embed: !0,
          ...u.label
        },
        u
      );
    } catch (u) {
      throw console.error(u), u;
    }
  };
}
function gi(e, t, n) {
  return Object.is(e, t) ? !0 : e === null || t === null ? !1 : Array.isArray(e) ? Ho(e, t, n) : typeof e == "object" ? mi(e, t, n) : !1;
}
function Ho(e, t, n) {
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let s = 0; s < r; s++)
    if (!gi(e[s], t[s], n))
      return !1;
  return !0;
}
function mi(e, t, n) {
  for (const r of Object.keys(e))
    if (!n?.has(r) && !(Object.prototype.hasOwnProperty.call(t, r) && gi(e[r], t[r], n)))
      return !1;
  return !0;
}
const { estree: hi } = Di, { embed: Ie } = hi, Xo = (e, t) => {
  const { node: n } = e;
  if (n.type !== "TemplateLiteral" || n.quasis.some(({ value: { cooked: o } }) => o === null))
    return null;
  const r = zo(e);
  if (typeof r == "string") {
    const o = Jo(
      t,
      r
    );
    for (const i of me) {
      let l = !1;
      for (const u of o(
        i
      ))
        if (r === u) {
          l = !0;
          break;
        }
      if (l)
        return xe(
          n,
          i,
          r,
          "comment",
          t
        );
    }
    return Ie?.(e, t) ?? null;
  }
  const s = Ko(e);
  if (typeof s == "string") {
    const o = ii(t, s);
    for (const i of me) {
      let l = !1;
      for (const u of o(i))
        if (s === u) {
          l = !0;
          break;
        }
      if (l)
        return xe(n, i, s, "tag", t);
    }
    return Ie?.(e, t) ?? null;
  }
  if (s !== void 0) {
    const o = (l) => So[t.parser].parse(
      l,
      t
    ), i = ii(t);
    for (const l of me) {
      let u;
      for (const E of i(l))
        if (Wo(s, E, o)) {
          u = E;
          break;
        }
      if (u !== void 0)
        return xe(
          n,
          l,
          u,
          "tag",
          t
        );
    }
  }
  return Ie?.(e, t) ?? null;
}, ra = {
  estree: {
    ...hi,
    embed: Xo
  }
};
export {
  sa as options,
  So as parsers,
  ra as printers
};
